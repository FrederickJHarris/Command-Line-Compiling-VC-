Command Line Compiling With Visual Studio 2019 (also works with several versions back)

1) Do a usual left-click on Windows Start Menu and scroll down to Visual Studio 2019.  There should be
   two entries there (at least there are on my installations) for Visual Studio.  On mine, the top entry
   has a 'drop down' button which reveals several more options, and the bottom one is a single shortcut
   which starts the Visual Studio IDE (Integrated Development Environment);

2) Don't start the IDE.  Instead, click the top entry's drop down arrow to reveal the other shortcuts.
   Locate the one that says 'x64 Native Tools Command Prompt for VS 2019'.  Click that one to open a
   command prompt console window which also configures that environment for x64 builds by the x64 build
   chain, which involves cl.exe for compiling source files, i.e., *.cpp, *.h, and *.rc files, and link.exe
   for linking *.obj files created by the compiler;

Let's build Dennis Ritchie's (the creator of C and the Unix operating system) famous Hello, World! program
from the command line so as to show how straightforward and ridiculously easy it is to build programs from 
the command line.

First, open Microsoft's Notepad.exe.  We'll use the simplest text editor possible for this, and prove to you
that it's possible to code without heavyweight IDE's.  If you don't have a shortcut to Notepad on your desktop
(you should!!!), find it on the Windows Start Menu under the 'W's - Windows Accessories >> Notepad.  Paste the 
following in Notpad....

// cl Hello.cpp
#include <stdio.h>

int main()
{
 printf("Hello, World!\n");
 getchar();

 return 0;
}

...then save that file to some directory/folder on your box where you want to save source files, and save it 
with an extension of *.cpp.  Might I recommend you create a seperate folder for the file and name the file
Hello.cpp?  As an example of what I've done on my system as I write this, I've a directory off my root
C Drive named Code, i.e., C:\Code.  Under that I have a directory for my Microsoft Visual Studio code named
C:\Code\VStudio.  It is under that directory I made another subdirectory named Hello which is where I saved
the above code as Hello.cpp, i.e.,...

C:\Code\VStudio\Hello\Hello.cpp

Now open a Visual Studio Command Prompt Window (or, maybe you have it open already if you followed my steps 1 
and 2 above) and use the CD (Change Directory) command to change the current or active directory to where 
you've just saved your Hello.cpp file.  For example, when I opened a command prompt window this is what I got...

**********************************************************************
** Visual Studio 2019 Developer Command Prompt v16.11.2
** Copyright (c) 2021 Microsoft Corporation
**********************************************************************
[vcvarsall.bat] Environment initialized for: 'x64'

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>

So you can see I'm in one of the Visual Studio installation directories.  We've got to move out of there to
where our Hello.cpp file is located.  The CD command will do that.  So to get us back to the root or C 
directory type CD\ at the command prompt and hit [ENTER], i.e.,...

CD\ [ENTER]

Then you should see this....

**********************************************************************
** Visual Studio 2019 Developer Command Prompt v16.11.2
** Copyright (c) 2021 Microsoft Corporation
**********************************************************************
[vcvarsall.bat] Environment initialized for: 'x64'

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>CD\

C:\>

Next, we'll 'move out' to where our Hello.cpp file is located.  So do another CD command to get to the directory
where you put your Hello.cpp file.  For me it's like so....

**********************************************************************
** Visual Studio 2019 Developer Command Prompt v16.11.2
** Copyright (c) 2021 Microsoft Corporation
**********************************************************************
[vcvarsall.bat] Environment initialized for: 'x64'

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>CD\

C:\>CD C:\Code\VStudio\Hello

C:\Code\VStudio\Hello>

So as you can see, I'm now in the \Hello subdirectory.  If I do a Dir command I'll see my Hello.cpp file as the 
only file there....

**********************************************************************
** Visual Studio 2019 Developer Command Prompt v16.11.2
** Copyright (c) 2021 Microsoft Corporation
**********************************************************************
[vcvarsall.bat] Environment initialized for: 'x64'

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>CD\

C:\>CD C:\Code\VStudio\Hello

C:\Code\VStudio\Hello>Dir
 Volume in drive C has no label.
 Volume Serial Number is 92DC-1CD1

 Directory of C:\Code\VStudio\Hello

09/26/2021  11:34 AM    <DIR>          .
09/26/2021  11:34 AM    <DIR>          ..
09/26/2021  11:33 AM                96 Hello.cpp
               1 File(s)             96 bytes
               2 Dir(s)  1,895,221,362,688 bytes free

C:\Code\VStudio\Hello>

Now let's build Hello.cpp into Hello.exe.  At the command prompt simply type...

cl Hello.cpp [ENTER]

You don't type the [ENTER] part.  You just type 'cl Hello.cpp' then press the [ENTER] key.  Here's what I see on my screen....

**********************************************************************
** Visual Studio 2019 Developer Command Prompt v16.11.2
** Copyright (c) 2021 Microsoft Corporation
**********************************************************************
[vcvarsall.bat] Environment initialized for: 'x64'

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>CD\

C:\>CD C:\Code\VStudio\Hello

C:\Code\VStudio\Hello>Dir
 Volume in drive C has no label.
 Volume Serial Number is 92DC-1CD1

 Directory of C:\Code\VStudio\Hello

09/26/2021  11:34 AM    <DIR>          .
09/26/2021  11:34 AM    <DIR>          ..
09/26/2021  11:33 AM                96 Hello.cpp
               1 File(s)             96 bytes
               2 Dir(s)  1,895,221,362,688 bytes free

C:\Code\VStudio\Hello>cl Hello.cpp
Microsoft (R) C/C++ Optimizing Compiler Version 19.29.30133 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.

Hello.cpp
Microsoft (R) Incremental Linker Version 14.29.30133.0
Copyright (C) Microsoft Corporation.  All rights reserved.

/out:Hello.exe
Hello.obj

C:\Code\VStudio\Hello>

Above is the full output from when I first opened a command prompt window for Visual Studio and Microsoft's build chain.
It's starting to add up and get confusing, so we can do a cls (clear screen) to get rid of what we don't want to see anymore.
But I thought it would be instructive up to this point to keep showing the complete history of what I'm doing so you can
follow along.  So anyway, you should be able to see above the output from the compiler - which is cl.exe, and from the linker,
which is link.exe.  The compiler is version 19 and the linker is version 14.  There were no errors reported, and the outputs
of the compiler and linker are shown above as Hello.exe - which is the output of the linker, and Hello.obj - which is the
output file from the compiler.  If you clear your console window with the cls command and do another dir command to see the
new contents of the \Hello subdirectory you should see something like so....


C:\Code\VStudio\Hello>dir
 Volume in drive C has no label.
 Volume Serial Number is 92DC-1CD1

 Directory of C:\Code\VStudio\Hello

09/26/2021  11:53 AM    <DIR>          .
09/26/2021  11:53 AM    <DIR>          ..
09/26/2021  11:33 AM                96 Hello.cpp
09/26/2021  11:53 AM           127,488 Hello.exe
09/26/2021  11:53 AM             2,539 Hello.obj
               3 File(s)        130,123 bytes
               2 Dir(s)  1,895,219,253,248 bytes free

C:\Code\VStudio\Hello>

As seen above we have a 96 byte Hello.cpp source file, a 127,488 byte executable, and a 2,539 byte Hello.obj file.  We can run
the Hello.exe file by simply typing it's name - with or without the extension, at the command prompt....


C:\Code\VStudio\Hello>Hello
Hello, World!
 
Note that you need to hit the [ENTER] key to cause the program to end because it will be 'stuck' in the C Runtime function
getchar() call waiting patiently for a keystroke.  Note that if you are having any troubles at this point, such as failing
to get my Hello.cpp file to build without errors, then you've done something wrong - perhaps not copying or typing my Hello.cpp
file correctly, and you need to backup and follow my directions EXACTLY!!!!  I'll assume from here on out that you are with me
at this point.

So lets's review and get a deeper understanding of what has gone on so far.  When we opened the Visual Studio's Command Prompt
it was just like any command prompt window except that in the shortcut to it Microsoft caused a batch file to run named 
vcvars64.bat which configured the environment for command line building using something termed in C or C++ parlance the 'Build 
Chain'.  On my system it's located here (I think, maybe)....

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.25.28610\bin\Hostx64\x64

It used to be very simple to find it, but the past few years it has gotten rather complicated.  But not to worry!  It doesn't
really matter where it is.  If you've followed my directions above, Hello.cpp will build correctly as the system will locate
everything correctly.  But it would be worth the reader's while to examine some of the files in the \bin folder of the build chain 
to at least locate the ones I'm describing here, specifically cl.exe and link.exe.

So let's get into this further.  At the top of Hello.cpp you'll see this line commented out....

// cl Hello.cpp

That line - minus the '//' comment characters, is what we fed into cl.exe - the MS VC++ compilere.  It is about the simplest
command line string possible that actually builds a binary file, i.e., executable.  In all my programs, at the top of the main
or startup module, I place these command line strings.  When I wish to build the program I simply copy the command line string
onto the clipboard, then paste it into the command prompt window, then hit [ENTER].  There are other ways to do it for larger
and more complex programs, and I'll get to describing that in the fullness of time, but for now as we're just starting out, let's
stick with this technique.

Obviously, things can become more complicated, so let's look at some of the modifications we can make to the above command line
string.  First we'll look at things termed compiler and linker 'switches'.  At the command prompt, clear your screen with cls, then
do this....

C:\Code\VStudio\Hello>cl /?

In other words, just type 'cl /?' [ENTER]

Wow!  That had a big effect, didn't it?  That's how one gets help on all the 'switches' cl.exe recognizes.  Note there is more info
there than will fit on one console screen so you have to keep hitting [ENTER] to scroll through all the data - maybe 6 or eight 
screen-fulls.  Let's try some!

If you want, delete Hello.obj and Hello.exe from your \Hello directory, and try this for a new command line string....

cl Hello.cpp /O1 /Os /FeHelloWorld.exe [ENTER]

In the above command line string the /O1, /Os, and /Fe terms tell the compiler to, respectively, optimize maximally for code
space, optimize for code space (somewhat redundant), and rename the output executable file a different name than the source file.
In the case above we rename it 'HelloWorld.exe' instead of the source code's Hello.exe.  If you execute the above and check out
your \Hello folder you'll see we now have a HelloWorld.exe.  On my system the optimizations had no effect.  Not much optimization
can be done to a simple program like that with only two function calls.

Let's try another instructive example before we move on to building GUI code.  Delete the Hello.obj and HelloWorld.exe files from
your \Hello directory and try this command line string....

cl Hello.cpp /c [ENTER]

Here is my command window after doing that and following it with a dir command to show the contents of the \Hello folder...

C:\Code\VStudio\Hello>cl Hello.cpp /c
Microsoft (R) C/C++ Optimizing Compiler Version 19.25.28614 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.

Hello.cpp

C:\Code\VStudio\Hello>dir
 Volume in drive C is Windows
 Volume Serial Number is 3230-2F4C

 Directory of C:\Code\VStudio\Hello

09/26/2021  06:37 PM    <DIR>          .
09/26/2021  06:37 PM    <DIR>          ..
09/26/2021  11:33 AM                96 Hello.cpp
09/26/2021  06:37 PM             2,521 Hello.obj
               2 File(s)          2,617 bytes
               2 Dir(s)  848,256,962,560 bytes free

C:\Code\VStudio\Hello>

If you examine the above carefully you might note (if you are really observant) that no executable file was created.  The only
output file of the compiler was Hello.obj.  The /c switch told the compiler to only compile the Hello.cpp source and output an
object file only - ignoring the next or linking step.  A compiler only knows about and examines one source code file at a time
and it more or less converts it into binary or machine code format, then outputs that file as seen above.  I qualified the
former sentence with the term 'more or less' because an object file can't be run or executed directly, because it isn't quite 
'done' yet; 'done' in the sense of a cooking metaphor, like a steak that's too raw yet to eat, or a cake not done in the middle
yet.  For you see, virtually all programs pull in external code not found in any particular source code file.  Indeed, that is
the case in the above Hello.cpp file.  There are two calls to external routines which are not present in the Hello.cpp source.
Those two calls are to a C Runtime function named printf() and another named getchar().  The actual binary code for those two
functions are contained in the C Runtime Library, and what the compiler will do when converting the Hello.cpp code to binary is
mark those function calls in such a way that the linker in the next link step can pull that binary code out of the necessary 
library and incorporate it into the final Hello.exe file.  

I failed to take note so far of the one include file in Hello.cpp.  That would be for #include <stdio.h>.  The compiler was able
to successfully build Hello.cpp into Hello.obj only because of the inclusion of that include.  If that include weren't there, the
compiler would issue an error and stop compiling.  So another way of looking at the compilation process is to recognize that the
compiler will compare each line in a program to what it considers as correct C or C++ syntax, as the case may be, and to what it
recognizes as a valid internal language function call, such as sizeof() for example, or to the prototype of a correct external
function call as found in an include file.  I leave it as an exercise for the reader to attempt compilation of the above Hello.cpp
file after commenting out the #include <stdio>.  The compiler will 'error out', which is bad, but the good part of it is that it
will tell you in the error output exactly what it didn't like, and which line number in the program was the subject of its ire.
This really is important, so maybe I ought to stop being lazy, do it myself, and show you the output.  So I slash, slashed stdio.h
and attempted to recompile and here is the output...

C:\Code\VStudio\Hello>cl Hello.cpp
Microsoft (R) C/C++ Optimizing Compiler Version 19.25.28614 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.

Hello.cpp
Hello.cpp(5): error C3861: 'printf': identifier not found
Hello.cpp(6): error C3861: 'getchar': identifier not found

C:\Code\VStudio\Hello>

So you see, with stdio.h commented out, the compiler can not make any sence out of printf on line 5 and getchar() on line 6.  These
'identifers' are not symbols the compiler knows anything about.  It simply can't continue and aborts with an error.  On the other
hand, if printf() and getchar() functions were implemented in Hello.cpp, the compiler would have been able to continue without any
includes, and output binary opcodes for everything, i.e., everything in main(), printf(), and getchar().  And the linker would have
an easy job.  Essentially, all it would need to do is output the executable almost exactly 'as is'.  So let's move on to the link 
step.




